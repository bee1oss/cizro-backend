generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/**
 * ===== Enums =====
 */

enum Role {
  ADMIN
  SELLER
  CLIENT
}

enum StoreStatus {
  PENDING
  APPROVED
  REJECTED
}

enum ProductStatus {
  DRAFT
  PENDING
  ACTIVE
  REJECTED
}

enum OrderStatus {
  PENDING
  PAID
  SHIPPED
  DELIVERED
  CANCELLED
}

/**
 * ===== Auth / Users =====
 */

model User {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  email    String  @unique
  password String
  fullName String?
  phone    String?

  roles Role[]

  // Relations
  stores         Store[]        @relation("StoreOwner")
  approvedStores Store[]        @relation("StoreApprovedBy")
  orders         Order[]        @relation("OrderBuyer")
  reviews        Review[]
  favorites      Product[] // M:N (User <-> Product)
  refreshTokens  RefreshToken[]

  @@map("user")
}

/**
 * ===== Store =====
 */

model Store {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  title       String
  description String?

  ownerId String
  owner   User   @relation("StoreOwner", fields: [ownerId], references: [id])

  status       StoreStatus @default(PENDING)
  approvedAt   DateTime?
  approvedById String?
  approvedBy   User?       @relation("StoreApprovedBy", fields: [approvedById], references: [id])
  rejectReason String?

  products Product[]
  reviews  Review[]

  @@index([ownerId])
  @@index([status])
  @@map("store")
}

/**
 * ===== Category (Tree) =====
 */

model Category {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  title String
  slug  String @unique

  parentId String?
  parent   Category?  @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children Category[] @relation("CategoryHierarchy")

  products Product[] // Her Product tek bir kategoriye bağlı (basit yaklaşım)

  @@unique([title])
  @@index([parentId])
  @@map("category")
}

/**
 * ===== Product (Mağazaya ait ürün kaydı) =====
 */

model Product {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  title       String
  description String?
  images      String[]
  price       Decimal       @db.Decimal(10, 2)
  stock       Int           @default(0)
  status      ProductStatus @default(PENDING)

  // İlişkiler
  storeId String
  store   Store  @relation(fields: [storeId], references: [id])

  categoryId String
  category   Category @relation(fields: [categoryId], references: [id])

  // Opsiyonel marka bilgisi
  brand String?

  // Varyant gerekiyorsa (renk/beden) basit alanlar:
  color String?
  size  String?

  reviews    Review[]
  orderItems OrderItem[]

  wishlistedBy User[] // favorites M:N karşılığı (implicit)

  // Arama ve raporlar için indexler
  @@index([storeId, status])
  @@index([categoryId])
  @@index([price])
  @@map("product")
}

/**
 * ===== Order & OrderItem =====
 */

model Order {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  buyerId String
  buyer   User   @relation("OrderBuyer", fields: [buyerId], references: [id])

  status OrderStatus @default(PENDING)
  total  Decimal     @db.Decimal(10, 2)

  items OrderItem[]

  @@index([buyerId])
  @@index([status, createdAt])
  @@map("order")
}

model OrderItem {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orderId String
  order   Order  @relation(fields: [orderId], references: [id])

  productId String
  product   Product @relation(fields: [productId], references: [id])

  storeId  String // denormalize: raporlama ve sorgu kolaylığı
  quantity Int

  // Sipariş anındaki snapshot (fiyat/ad başlık değişse bile geçmiş sabit kalsın)
  priceAtPurchase Decimal @db.Decimal(10, 2)
  titleAtPurchase String?

  @@index([orderId])
  @@index([productId])
  @@index([storeId, createdAt])
  @@map("order_item")
}

/**
 * ===== Review =====
 */

model Review {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  authorId String
  author   User   @relation(fields: [authorId], references: [id])

  productId String?
  product   Product? @relation(fields: [productId], references: [id])

  storeId String?
  store   Store?  @relation(fields: [storeId], references: [id])

  rating Int
  text   String

  @@index([authorId])
  @@index([productId])
  @@index([storeId])
  @@map("review")
}

/**
 * ===== Refresh Token (hash + rotation) =====
 */

model RefreshToken {
  id        String    @id @default(cuid())
  tokenHash String    @unique
  userId    String
  user      User      @relation(fields: [userId], references: [id])
  createdAt DateTime  @default(now())
  expiresAt DateTime
  revokedAt DateTime?
  userAgent String?
  ip        String?

  replacedById String?
  replacedBy   RefreshToken?  @relation("RTReplace", fields: [replacedById], references: [id])
  replaced     RefreshToken[] @relation("RTReplace")

  @@index([userId])
  @@index([expiresAt])
  @@map("refresh_token")
}
